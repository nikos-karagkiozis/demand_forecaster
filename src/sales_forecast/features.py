# features.py
"""
This module contains functions for feature engineering based on the daily sales data.
It generates temporal, lagged, and rolling window features to prepare the data
for a sales forecasting model.
"""

import pandas as pd
import numpy as np

def create_temporal_features(df: pd.DataFrame) -> pd.DataFrame:
    """
    Extracts temporal features from the 'Date' column.

    Args:
        df (pd.DataFrame): Input DataFrame with a 'Date' column (datetime type).

    Returns:
        pd.DataFrame: DataFrame with added temporal features.
    """
    df['year'] = df['Date'].dt.year
    df['month'] = df['Date'].dt.month
    df['day'] = df['Date'].dt.day
    df['day_of_week'] = df['Date'].dt.dayofweek  # Monday=0, Sunday=6
    df['week_of_year'] = df['Date'].dt.isocalendar().week.astype(int)
    df['day_of_year'] = df['Date'].dt.dayofyear
    df['quarter'] = df['Date'].dt.quarter
    return df

def create_lagged_features(df: pd.DataFrame, target_col: str = 'total', lags: list = None) -> pd.DataFrame:
    """
    Creates lagged features for the target variable.

    Args:
        df (pd.DataFrame): Input DataFrame, sorted by 'Date'.
        target_col (str): Name of the target column to create lags for.
        lags (list): List of integers representing the number of periods to lag.
                     Defaults to [1, 7, 14] (yesterday, last week, two weeks ago).

    Returns:
        pd.DataFrame: DataFrame with added lagged features.
    """
    if lags is None:
        lags = [1, 2, 3, 7, 14]

    for lag in lags:
        df[f'{target_col}_lag_{lag}'] = df[target_col].shift(lag)
    return df

def create_rolling_features(df: pd.DataFrame, target_col: str = 'total', windows: list = None) -> pd.DataFrame:
    """
    Creates rolling window features (mean and std) for the target variable.

    Args:
        df (pd.DataFrame): Input DataFrame, sorted by 'Date'.
        target_col (str): Name of the target column to create rolling features for.
        windows (list): List of integers representing the window sizes.
                        Defaults to [3, 7] (3-day and 7-day rolling).

    Returns:
        pd.DataFrame: DataFrame with added rolling features.
    """
    if windows is None:
        windows = [2, 3, 4, 5, 6, 7]

    for window in windows:
        df[f'{target_col}_rolling_mean_{window}'] = df[target_col].shift(1).rolling(window=window).mean()
        df[f'{target_col}_rolling_std_{window}'] = df[target_col].shift(1).rolling(window=window).std()
    return df

def encode_categorical_features(df: pd.DataFrame) -> pd.DataFrame:
    """
    Encodes categorical features using one-hot encoding.

    Args:
        df (pd.DataFrame): Input DataFrame.

    Returns:
        pd.DataFrame: DataFrame with one-hot encoded categorical features.
    """
    # 'holiday_name' is the only explicit string categorical feature from data_ingest.py
    if 'holiday_name' in df.columns:
        df = pd.get_dummies(df, columns=['holiday_name'], prefix='holiday', drop_first=True)
    return df

def generate_features(df: pd.DataFrame) -> pd.DataFrame:
    """
    Orchestrates the creation of all features.

    Args:
        df (pd.DataFrame): Raw input DataFrame. Assumes 'Date' is already datetime.

    Returns:
        pd.DataFrame: DataFrame with all engineered features.
    """
    df = df.sort_values('Date').reset_index(drop=True)

    # Build engineered features
    df = create_temporal_features(df)
    # Defaults used when arguments are None inside the helpers
    default_lags = [1, 2, 3, 7, 14]
    default_windows = [2, 3, 4, 5, 6, 7]
    df = create_lagged_features(df, lags=None)
    df = create_rolling_features(df, windows=None)
    df = encode_categorical_features(df)

    # Instead of dropping all rows with any NaN, limit the drop to the warmup
    # region required by lag/rolling features, then impute remaining NaNs.
    # Earliest fully-available row is governed by max lag and rolling window+1 (due to shift(1)).
    warmup = max(max(default_lags), max(default_windows) + 1)
    if len(df) > warmup:
        df = df.iloc[warmup:].copy()

    # Impute remaining missing values to avoid losing rows due to sparse inputs
    # - For numeric columns (excluding target), fill with column median
    # - For one-hot columns generated by get_dummies, fill 0
    # - Non-numeric columns (if any remain) get forward/backward fill as a fallback
    numeric_cols = df.select_dtypes(include=[np.number]).columns.tolist()
    if 'total' in numeric_cols:
        # Avoid leaking target statistics into features; handle target separately if needed
        numeric_impute_cols = [c for c in numeric_cols if c != 'total']
    else:
        numeric_impute_cols = numeric_cols
    for c in numeric_impute_cols:
        med = df[c].median()
        df[c] = df[c].fillna(med if pd.notna(med) else 0)

    # Remaining non-numeric missing values: forward then backward fill as conservative defaults
    non_numeric_cols = [c for c in df.columns if c not in numeric_cols]
    if non_numeric_cols:
        df[non_numeric_cols] = df[non_numeric_cols].ffill().bfill()

    return df

def prepare_dataset_for_modeling(df: pd.DataFrame, target_col: str = 'total') -> tuple[pd.DataFrame, pd.Series]:
    """
    Prepares the dataset for modeling by separating features (X) and target (y).

    Args:
        df (pd.DataFrame): DataFrame with engineered features.
        target_col (str): Name of the target column.

    Returns:
        tuple[pd.DataFrame, pd.Series]: X (features) and y (target) DataFrames.
    """
    # Exclude 'Date' and the original target column from features
    features = df.drop(columns=['Date', target_col], errors='ignore')
    target = df[target_col]

    return features, target
